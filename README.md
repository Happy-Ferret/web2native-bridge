# Web2Native Bridge - Emulator
This repository contains all code for building and testing an emulation of
the Web2Native Bridge concept
(https://cyberphone.github.io/openkeystore/resources/docs/web2native-bridge.pdf)
using the Google Chrome (desktop) browser.

The emulator code exploits Chrome's native messaging (https://developer.chrome.com/extensions/nativeMessaging)
featured in a single universal Chrome extension.

Applications callable by the Web2Native Bridge emulator **must** be written in Java and stored in a for the purpose
dedicated directory.  This limits unpleasant surprises
(an improperly designed native message extension could enable access to *any* application!)
if you accidentally navigate to a malicious page.
### API
The Web2Native Bridge emulator extends the **navigator** object by a *single* method **nativeConnect**(*NameOfTargetApplication*) which
returns a promise holding a **port** object.

The **port** object supports the following methods and events:
* **postMessage**(*JSONObject*)
* **disconnect**()
* **addMessageListener**(function(*JSONObject*))
* **addDisconnectListener**(function())

An example which could be hosted in an ordinary (*non-privileged*) web page:
```javascript
navigator.nativeConnect('com.example.w2nb.sample').then(function(port) {

    port.addMessageListener(function(message) {
        // We got a message from the native application...
    });

    port.addDisconnectListener(function() {
        // Native application disconnected...
    });

    port.postMessage({greeting:'Native app, how are you doing?'});
    // Note: JS serialization makes the above a genuine JSON object

    port.disonnect();  // Not much of a conversation going on here...

}, function(err) {
    console.debug(err);
});
```
The argument to **nativeConnect** holds the name of the specifically adapted local application to invoke.   The current scheme uses a Java-inspired dotted path pointing to a subdirectory and JAR-application having this name.

### Architecture
The Web2Native Bridge emulator always invokes a central proxy located at <code>proxy/install/w2nb-proxy</code>.<br>
The proxy in turn delegates a call to the specific target application located at<br><code>
proxy/install/apps/</code>*dottedpath*<code>/</code>*dottedpath*<code>.jar</code>.

All I/O is between the components is performed through <code>stdin</code> and <code>stdout</code>.

For debugging purposes there is also a logging system writing data in <code>proxy/install/logs</code>.

### Installation
Prerequisites: You need to have Java SE version 7 or 8 installed to run the Web2Native Bridge emulator. OS/X and Linux
installations also presume that <code>clang</code> respectively <code>g++</code> is available.

1. Clone the <code>web2native-bridge</code> project or just download the ZIP via GitHub to any free directory
2. Install the Chrome browser extension available in <code>extension/src</code> as described in https://developer.chrome.com/extensions/getstarted#unpacked
3. Update the property "allowed_origins" in <code>proxy/install/org.webpki.w2nb.json</code> so that it matches the value generated by the Chrome browser
4. Start a terminal window and move to <code>proxy/install</code>. Then run the <code>install-proxy</code> script that suits your platform

### Sample Application
The HTML file <code>sample1/demo/sample1.html</code> does approximately
the same thing as the application depicted in
http://www.cnet.com/news/google-paves-over-hole-left-by-chrome-plug-in-ban/
albeit with two major differences:
* The sample application runs in an ordinary web page
* The Web2Native Bridge browser extension is fully generic

The native part of the sample application resides in <code>proxy/install/apps/org.webpki.w2nb.sample1/org.webpki.w2nb.sample1.jar</code>.

### Security Considerations
Since an emulator *by definition* isn't the "real thing" some limitations apply. That is, the Web2Native Bridge
emulator is *not intended for production* since it lacks the following security features:
* Vetted native application infrastructure (also absent from Google's take on the matter)
* HTTPS information (unavailable in the Chrome native messaging interface)
* Site-blocking support and associated administration

In addition, the scheme injects code in every web page visited which is a core "feature" of Chrome extensions
slowing down execution.  It is probably wise disabling the extension (using Chrome *settings*) when not using it.
